
# Java发展史

## 一、Java起源

### 1. 起源背景

Java最初由James Gosling和他的团队在Sun Microsystems公司于1991年发明，主要目的是设计一种适用于消费电子产品的软件平台，具有跨平台能力、简单易用。当时，消费电子产品市场正在快速发展，但各品牌设备之间的兼容性问题严重，Sun Microsystems公司决定启动一个代号为“Green Project”的项目，目标是开发一种能够在各种消费电子设备上运行的软件平台。

最初，Gosling给这门新语言取名为“Oak”，这是因为他办公室外有一棵橡树（Oak Tree）。然而，由于“Oak”这个名字已经被注册为商标，他们不得不另选新名。最终，他们选择了“Java”，这个名字来源于印尼爪哇岛的咖啡（Java Coffee），象征着语言的活力和创新。

1995年5月23日，Java语言正式发布，并首次引入了“Write Once, Run Anywhere”（WORA）的理念。

## 二、Java不同版本

### Java SE

- **J2SE 1.2 (1998年12月8日)**：引入了JIT（Just In Time）编译器技术，使得语言的可迁移性和执行效率达到最优的平衡，同时Collections集合类设计优良，在企业应用开发中迅速得到了广泛使用。
- **Java SE 5.0 (2004年9月30日)**：引入了泛型、增强循环、枚举、注解等重要语言特性。
- **Java SE 8 (2014年3月18日)**：引入了Lambda表达式、Stream API和新的日期时间API，极大地提升了Java在函数式编程和数据处理方面的能力。
- **Java SE 11 (2018年9月25日)**：成为长期维护版本（LTS），继续改进语言特性，包括模式匹配和Sealed类等。
- **Java SE 17 (2021年9月)**：最新的长期维护版本（LTS），继续改进语言特性，包括模式匹配和Sealed类等。

## 三、Java特性

### Java跨平台性

开发者在不同平台上开发程序，曾经深受平台依赖性之苦，像C/C++等语言，编写的程序需要根据不同的操作系统和硬件平台进行手动适配，耗费大量时间精力。Java的出现宛如救星，凭借跨平台性，在程序开发领域掀起巨大变革。

当开发一个项目时，团队成员使用的电脑配置各异，有的是Windows系统，有的是Mac系统。如果用C/C++开发，就需要针对不同系统编译不同版本，不仅复杂，而且极易混淆。而Java就像一个通用的桥梁，开发人员只需将Java源代码（.java文件）通过Java编译器（javac）编译成Java字节码（.class文件），这字节码不针对特定硬件或操作系统，是一种抽象的机器指令，之后无论是在Windows、Linux还是Mac OS操作系统上，只要安装了对应的Java虚拟机（JVM）实现，程序就能流畅运行。JVM好比一个全能翻译官，它根据操作系统特性，将字节码精准翻译成相应的机器码，实现不同平台的无缝对接。这样我们就可以在不同平台上专注于业务逻辑开发，无需为适配各种环境分散精力，极大提升开发效率，降低维护成本。

例如，开发企业级应用时，前端开发人员可在Mac上高效设计界面，后端开发人员用Windows完成逻辑编写，测试人员在各类系统环境下全面测试，随后将程序部署到运行Linux的服务器上。整个过程中，无需针对不同平台修改代码，编译一次，到处运行，真正实现“Write Once, Run Anywhere”。

### 垃圾回收（Garbage Collection，GC）

在开发过程中，内存管理是至关重要且极易出错的环节。此前，如C/C++这般语言，将内存分配与回收全权交给开发者，这要求开发者对内存管理有深入了解，稍有不慎，就会导致内存泄漏、非法内存访问等严重问题。

以开发一个大型游戏为例，游戏中有大量角色、场景、道具等对象，频繁创建与销毁，若手动管理内存，不仅要时刻跟踪每个对象的生命周期，还要准确判断何时释放内存，这不仅大大增加代码量，还容易因疏忽引发程序崩溃。

Java引入垃圾回收机制，解决了这一难题。在Java程序运行时，所有对象都存储于Java堆（Heap）中，JVM负责堆中对象的内存分配。垃圾回收器通过引用追踪（Reference Tracking）确定对象的活动状态。开发过程中，我们创建大量对象，随后部分对象不再被引用，变成垃圾。此时，垃圾回收器定期扫描堆中的对象，标记所有可以访问到的对象，接着清除未被标记的对象，回收其占用的内存。通常，这一过程分为标记阶段（Marking）与清除阶段（Sweeping）。同时还对回收后内存进行合理分配与空间整理，减少内存碎片，确保后续对象能分配到合适连续内存块，避免频繁寻找可用内存导致的性能损耗。

以电商网站开发为例，用户浏览商品时会创建购物车、商品详情等对象，下单后这些对象不再被引用，垃圾回收器自动清理，释放内存，供新对象使用。这不仅减轻开发者负担，让他们能更专注业务逻辑开发，如优化购物车算法、提升支付流程安全性，还提升代码稳定性与健壮性，降低因内存管理问题引发的程序崩溃风险。

### JIT（Just-in-Time Compilation）

在开发早期版本Java程序时，大家很快发现纯解释执行的性能瓶颈。比如开发一个计算密集型的科学计算应用，像对大量气象数据进行复杂模型计算，程序运行速度慢如蜗牛。每次执行字节码都需要JVM解释，性能远远达不到实际应用要求。

于是，Java引入JIT（Just-in-Time Compilation）技术，为性能优化开辟全新路径。运行程序时，JVM先加载class文件，并以解释方式执行字节码，这种方式确保跨平台特性。但JIT编译器同时登场，它实时监测程序运行，识别热点代码，这些热点代码往往是程序的核心业务逻辑，频繁执行，如电商系统中订单处理、支付环节相关代码。JIT编译器识别出后，立即将热点字节码在后台编译成本地机器码，编译完成的机器码存储于JVM内存，供后续重复快速执行。此外，JIT编译器对机器码进行优化，如循环展开、公共子表达式消除等，进一步提升执行效率。JVM还会缓存优化后的机器码，下次遇到相同热点代码，直接使用缓存代码，无需重新编译。

以开发视频编码软件为例，软件运行中存在大量图像处理热点代码，JIT编译器将其编译优化，大幅提升视频编码速度，从可能的数小时缩短至几十分钟，显著提高视频编码效率，使Java程序性能与本地编译的C或C++程序相媲美。